+++
title = "Ускоряем генерацию Open Graph изображений на Rust"
date = "2024-10-25"
draft = true

[taxonomies]
tags = ["Rust", "Блог"]

[extra]
comment = true
toc = true
og_image = "og-image.jpeg"
+++

Я уже говорил, что решение по генерации изображений для соцсетей из прошлой [статьи](/posts/ogimages-rust) неидеально &mdash; оно требует установленного Google Chrome, запускает его, ждёт пока страница загрузится и потом делает скриншот.

Во второй части этого цикла статей я покажу, как у меня получилось улучшить производительность и удобство своего приложения для генерации OG Image, а ещё добавить автоматическую генерацию этих изображений при публикации нового черновика.

<!--more-->

# В чём соббсна проблема?

По сути все проблемы сводятся в одну:

- Тяжёлая внешняя зависимость, которая может быть не всегда доступна (например, на CI-сервере) &mdash; Google Chrome;
- Медленная генерация из-за необходимости ждать браузер (загрузки страницы, шрифтов, необходимых стилей), на моей системе это где-то 600 мсек на изображение, возможно, это не так много, но всё равно неприятно;
- По какой-то неясной мне причине (баг в Chrome?) браузер, стартуя в headless режиме всё равно отображает своё окно без интерфейса &mdash; просто белый прямоугольник висит всё время генерации.

# Тогда избавимся от браузера

Отличная идея! Вспомним, что делает `@vercel/og`: он работает в реальном времени, генерируя SVG-изображения на лету из JSX и отдавая затем растровое изображение. В моём случае это работать не будет, потому что никакого веб-сервера нет, бразуер получает сразу предварительно собранный HTML.

Но вот что мы можем позаимствовать, так это генерацию SVG. Понадобится немного математики и понимания того, а как SVG вообще устроен.

# Что такое SVG?

Это растровый формат изображений, который оперирует примитивами: текстом, линиями, прямоугольниками, полигонами и т. д. Плюс в том, что это текстовый формат, основанный на XML, который можно легко генерировать программно.

SVG поддерживает написание стилей во встроенном CSS, но набор правил несколько ограничен, например не поддеживаются динамические средства позиционирования элементов (Flexbox, Grid), поэтому понадобится немного математики, чтобы рассчитать фиксированные координаты объектов.

# Выбросим лишнее

## Зависимости

Зависимости в Rust управляются своим пакетным менеджером, Cargo. У каждого проекта, который им собирается должен быть вот такой файл `Cargo.toml`

```toml
[package]
name = "og-builder"
version = "0.1.0"
edition = "2021"

[dependencies]
toml = "0.8.19"
regex = "1.7"
tera = "1"
chromiumoxide = { version = "0.7.0", features = ["tokio-runtime"] }
tokio = { version = "1.40.0", features = ["full"] }
tokio-stream = { version = "0.1.16" }
walkdir = "2.5.0"
serde = { version = "1.0.210", features = ["derive"] }
urlencoding = "2.1.3"
anyhow = "1.0.89"
clap = { version = "4.5.20", features = ["derive"] }
```
Здесь в числе прочей информации перечислены зависимости, которые нужны приложению для работы.  Так, мы можем смело выкинуть `tera` (использовался для создания HTML из шаблона), `chromiumoxide` (непосредственно запускатор браузера), `tokio` и `tokio-stream` (использовались для управления асинхронностью, которая теперь не нужна).
