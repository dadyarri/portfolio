+++
title = "Настраиваемые Open Graph изображения на Rust"
date = "2024-11-30"
draft = true

[taxonomies]
tags = ["Rust", "Блог"]

[extra]
comment = true
toc = true
og_image = "og-image.jpeg"
+++

Предыдущая [статья](/posts/better-ogimages-rust) цикла предоставила способ быстро генерировать Open Graph изображения. Проблема в этом решении в том, что дизайн изображений был жёстко зафиксирован в коде, что не позволяло изменить то, как будет выглядеть финальное изображение без редактирования кода и его пересборки. Это уже не говоря о том, что там производилась дозапись в файл при каждом добавлении нового элемента.

Поэтому в этой статье расскажу о том, как я вынес всю конфигурацию изображений в TOML-файл и настроил автоматизацию генерации на Github Actions.

<!--more-->

# Решение

Чтобы сделать генерацию изображений более гибкой, я решил использовать внешний файл конфигурации. Существуют разные форматы, такие как JSON и YAML, но я предпочёл TOML, так как он отличается простотой, читабельностью и широко используется в экосистеме Rust. TOML легко воспринимается как человеком, так и машиной, и, в отличие от YAML, не подвержен непредсказуемым ошибкам, вызванным различными парсерами.

Я разработал следующую структуру конфигурационного файла:

- Блок `[image]` описывает общие параметры для всего изображения, такие как размер холста и отступы между элементами.

- Блок `[[fonts]]` описывает используемые шрифты, включая их название и путь к файлу. Может быть несколько таких блоков, по одному на каждый шрифт.

- Блок `[background]` задаёт фон изображения и, при необходимости, стиль границ холста.

- Блок `[[sections]]` описывает содержимое изображения. Можно создать как простые секции, отображающие данные из преамбулы, так и более сложные, объединяющие несколько ключей и включающие настраиваемый формат. Здесь же можно задать стили для каждой секции и формат даты.

Ранее в проекте уже использовался TOML для чтения преамбул страниц. Я модифицировал этот механизм, чтобы использовать динамические объекты, так как структура преамбул теперь может быть разной, а структура конфигурации генератора остаётся фиксированной и предсказуемой.

Например, появилась функция, которая позволяет удобно доставать вложенные ключи из прочитанного объекта:

```rs
pub fn get_nested_value<'a>(preamble: &'a Value, keys: &str) -> Option<&'a Value> {
    let mut current_value = preamble;
    let split: Vec<&str> = keys.split('.').collect();

    debug!("Attempting to get nested value for keys: {}", keys);

    for key in split {
        debug!("Accessing key: {}", key);
        current_value = match current_value.get(key) {
            Some(value) => value,
            None => {
                debug!("Key not found: {}", key);
                return None;
            }
        };
    }

    debug!("Successfully retrieved value for keys: {}", keys);

    Some(current_value)
}
```