+++
title = "Генератор сайтов с блэкджеком и плагинами"
date = "2024-12-27"
draft = true

[taxonomies]
tags = ["Болтология"]

[extra]
comment = true
toc = true
og_image = true
+++

Доведя свой генератор Open Graph изображений до логичного финала я пришёл к выводу, что Rust - это не мой язык. Мне неприятно на нём писать и я больше времени трачу на то, чтобы победить злой компилятор, чем на привнесение нового функционала. Поэтому я стартую новый цикл статей о разработке своего генератора статических сайтов.

<!--more-->

Да, Zola (нынешний генератор, на котором крутится этот сайт) меня во многом устраивает. Он быстрый, хорошо выполняет свою задачу. Мне очень понравилась его идея "one binary to rule them all", благодаря чему мне не нужен целый Node.js проект с кучей зависимостей, чтобы поднять примитивный сайт, как было раньше (во времена Astro, например).

Но некоторого функционала в нём всё же не хватает. Взять ту же генерацию Open Graph изображений для публикации в соцсетях. Да, я написал свой генератор на абсолютно не знакомом мне языке с мыслью о том, чтобы потом встроить его в Zola.

Потратив на этот проект два месяца, я понял, что нервы мне дороже и погружаться ещё и в чужой код на Rust я не хочу, поэтому просто доделал базовый функционал, которого мне было достаточно и оставил его пылиться в бесконечно вечном.

В этом цикле я опишу свой путь по написанию генератора статических сайтов (далее SSG) с полного нуля до состояния, при котором мне самому будет будет удобно этим пользоваться, попутно переводя этот сайт на новый генератор.

# Название

Вдохновляться я буду Zola, поэтому и идею названия позаимствую оттуда. Эмиль Золя - это французский поэт и журналист 19 века. Я же возьму русского поэта. Так уж вышло, что русские фамилии паршиво выглядят на латинице, поэтому возьму что-то звучащее более интересно. Например, Иосифа Бродского. И стихи красивые, и имя латиницей выглядит хорошо. Живых проектов на гитхабе с таким названием нет - берём!

`Brodsky`, мне кажется, неплохо.

# Функционал

Что я хочу видеть в SSG?

- Формат распространения: Один бинарник
- Функционал:
  - Сборка Markdown документов в HTML-страницы по шаблону (ну это база)
  - Поддержка CSS-препроцессора (писать чистый CSS больно)
  - Централизованное управление шрифтами (кодогенерация стилей, например)
  - Минификация изображений
  - Поддержка тем
  - Поддержка плагинов (простое встраивание нового функционала в существующий код)
  - Дружелюбный CLI
  - Генерация Open Graph изображений

# Технология

Полагаясь на требования, выберу технологию, на которой я буду писать. У меня три варианта:

- Родной C#;
- F#, который я не знаю, но он всё ещё часть мира .NET, поэтому погружение не должно занять много времени
- Незнакомый мне Go


И хотя C# самый очевидный и простой вариант, потому что это моя основная специализация и моя full-time работа связана с ним, я не смогу его взять для этого проекта из-за того, что он не может обеспечить необходимыми библиотеками (например, там нет современных нативных реализаций CSS-препроцессоров).

По этой же причине я не могу взять F#, хотя мне хочется погрузиться в функциональное программирование.

Остаётся Go. Он даёт большую часть необходимого инструментария, работает быстро, компилируется в нативные бинарники, выглядит просто и читаемо. А что ещё нужно?

Да, тут тоже нет реализации ни одного CSS-препроцессора, но по остальному функционалу - Go даёт больше всех возможностей. Только у Sass есть не-node.js реализация, но она на Dart. Брать язык, о котором я знаю ещё меньше только из-за референсной реализации одной из множества функций в ущерб остальным (Dart обделён другими вещами), кажется, не самая удачная идея.

Есть три идеи. Временная, глупая и безумная:

- Отложить поддержку CSS-препроцессоров
- Использовать libsass. Это старая реализация компилятора Sass на C++, которая уже несколько лет признана устаревшей и не получает обновлений. Её можно без особых проблем присобачить к Go-приложению, но тогда не будет поддержки новых функций Sass, который с тех пор очень сильно развился
- Написать свою реализацию компилятора. Да, это сложно, не факт, что того стоит, но зато не будет никаких внешних зависимостей

Есть ещё вариант, который мне не особо нравится, но он самый простой: сказать, что dart-sass зависимость, которую нужно установить извне и использовать её через спавн процесса. Не нравится потому, что теряется концепция одного бинарника на управление всем.

Энивей, сейчас этот этап можно безопасно пропустить и реализовать поддержку препроцессинга CSS когда-нибудь потом.

# Концепция

# Заключение

Давненько не было болтологических лонгридов. В общем, какой формат этого цикла статей: сейчас я перешёл на фиксированный график публикации статей (одна статья в конце месяца), поэтому я просто в свободное время буду заниматься этим проектом и в формате статей показывать, что изменилось. Возможно, будут и другие темы в перемешку с этой.