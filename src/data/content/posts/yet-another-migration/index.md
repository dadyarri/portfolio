---
title: "Переезд блога на другой фреймворк (да, опять)"
date: "2025-05-31"
draft: true
tags: ["chatterbox", "blog"]
series: "ssg"

---

Прошло куча времени, как я начал писать [свой генератор статических сайтов](/posts/ssg-with-blackjack-and-plugins). Но спустя пару месяцев я пришёл к выводу, что в одиночку проект такого масштаба не потяну. Поэтому пришло время мигрировать на технологию, которой я изначально хотел избежать.

<!--more-->

В процессе построения архитектуры генератора статических сайтов я понял, что полноценного решения с плагинами на Go я не напишу. Слишком много ограничений, которые я (как разработчик-одиночка с фул-тайм работой) не смогу преодолеть. Например, плагины пришлось бы встраивать непосредственно в исходники (довольно неудобно и быстро засорит код), либо предоставлять способ запускать сторонние бинарники (потенциально небезопасно и потребовало бы собственного репозитория плагинов). В общем, эту реализацию я бросил и пришёл к тому, чего хотел всеми силами избежать. **JavaScript**. 

![](you-should-fight.jpg)

Вообще говоря, я изначально держал мысль писать проект на JavaScript как запасную, но откладывал её из-за того, что конечному пользователю вместо того, чтобы просто держать простую папку с его контентом, придётся создавать ещё и полноценный JavaScript-проект, который может разрастись до безумных размеров, не говоря уже про конфликты зависимостей и прочие радости жизни.

Но у такого подхода есть и свои плюсы. Как бы это ни было прискорбно, JavaScript всё ещё основная технология в современном вебе (как-нибудь потом расскажу, почему я считаю, что это плохо), поэтому здесь есть все необходимые мне инструменты, включая Sass и PostCSS. Имея все это напрямую без костылей, можно сделать подготовку ресурсов к публикации достаточно удобной, а прибитый гвоздями к языку NPM сильно упрощает работу с системой плагинов.

С другой стороны у этого проекта пропадает ценность, как у чего-то уникального. На Go есть [Hugo](https://gohugo.io) – вполне состоявшийся генератор статических сайтов. Но вся расширяемость в нем ограничена написанием кастомных макросов для шаблонизатора и скриптов. И это совсем не то, что мне нужно, то есть сложную логику на стороне сборщика к Hugo я добавить не могу. Поэтому на Go мой проект имел какой-то смысл и мог принести что-то своё.

В JavaScript мире есть [Astro](https://astro.build), который способен на всё то, что я хотел бы видеть в своем генераторе сайтов с блекджеком и плагинами. И писать свой такой же, кажется, смысла особого нет, ведь Astro — уже проверенный временем и сообществом инструмент, а я, как одиночка, лишь впустую потрачу время, пусть и получив опыт в технологии, которая мне никогда особо не нравилась.

Так что думаю, мне стоит просто написать свои интеграции к Astro с необходимым мне функционалом и перетащить блог на него обратно.

# Переезд на Astro

Когда-то этот блог уже работал на нём. Я в то время вместо того, чтобы регулярно что-то писать, часто прыгал с фреймворка на фреймворк. 11ty, Astro, Lume, Zola… Here we go again…

![](scheisse.png)

Но эта попытка отличается от всех предыдущих. Если раньше я старался не погружаться в дебри веб-технологий и просто брал готовую тему и с минимальными правками запускал сайт, то перебравшись на Zola, я через некоторое время написал свою тему практически с нуля, взяв разве что готовую цветовую схему Tokyo Night. Эта реинкарнация на Astro продожает идеи той темы, но снова переписана с нуля, причёсана и улучшена. Кроме того, я добавил красивое резюме. Кажется, теперь получилось совсем хорошо.

И вот, когда редизайн готов, можно задуматься о том, чтобы наполнить его нужным мне функционалом. Просто статический сайт это, конечно, хорошо, но хотелось бы, чтобы он красиво выглядел и за пределами сайта. Для этого существует Open Graph, о котором я уже не раз говорил в цикле [про генерацию изображений](/posts/series/ogimages). Это протокол, который говорит соцсетям, как отображать ссылки на сайт при отправке. В результате получается карточка с описанием и обложкой. И вот эту обложку как раз и нужно генерировать для каждого выходящего поста.

# Astro Integrations

Первое что приходит на ум — использовать встроенные в фреймворк инструменты. Astro позволяет писать кастомные [хуки](https://docs.astro.build/en/reference/integrations-reference) к различным событиям в процессе сборки сайта. Один из них даёт достаточное количество информации для генерации изображения. Это [`astro:build:done`](https://docs.astro.build/en/reference/integrations-reference/#astrobuilddone), который вызывается после завершения сборки и очистки лишнего мусора. Попробуем навесить свою интеграцию на это событие.

```typescript
"hooks": {
    "astro:build:done": async ({ dir, pages }) => {

    }
}
```

`dir` здесь это путь к исходникам сайта, в моём случае `./src`. `pages` — массив объектов с одним полем `pathname`. Это адрес сгенерированной страницы. По умолчанию Astro генерирует "красивые адреса", то есть вместо того, чтобы создать HTML файл с идентификатором поста, например, он создаёт отдельную папку, в которую кладёт `index.html`. Браузеры воспринимают такой адрес по умолчанию и не добавляют название файла в конце. Такой же адрес и попадает в этот массив.

Уже этой информации хватит, чтобы пробежаться по проекту и получить необходимые пути к файлам для генерации.

```typescript
const rootPath = fileURLToPath(new URL('..', dir));
const imagesPath = path.join(rootPath, "public", "content");
const fontsPath = path.join(rootPath, "public", "fonts");
const contentPath = path.join(rootPath, "src", "data", "content");
```